--O PRIMEIRO TIPO DE CONSULTA MAIS AVANÇADAS QUE VAMOS VER É O LIKE
--ELE FUNCIONA APENAS PARA TEXTOS
--ELE É MELHOR QUE USAR A CONDIÇÃO = ''
--PQ NELE TEMOS A % - ISSO INDICA UM "NÃO IMPORTA OQ VEM ANTES/NÃO IMPORTA
--OQ VEM DEPOIS
--SE EU COLOCAR SABOR = 'MACA' A BUSCA VAI SER EXATAMENTE POR ESSE TEXTO
--COM O LIKE PODEMOS FAZER SABOR LIKE '%MACA%, OU SEJA TENDO MACA ME RETORNA
-- NÃO IMPORTA SE É "CEREJA E MACA", "MACA E SEREJA" OU SOMENTE "MACA" ELE
--IRA RETORNAR
SELECT * FROM TABELA_DE_PRODUTOS WHERE SABOR LIKE '%Maca%';

SELECT * FROM TABELA_DE_PRODUTOS WHERE SABOR LIKE '%Maca%' AND EMBALAGEM = 'PET';

--AGORA O DISTINCT - SE DERMOS UM "SELECT CAMPOS QUE QUEREMOS
--(SENDO TODOS* OU ESPECIFICOS) EM UMA TABELA" PODEMOS TER LINHAS REPETIDAS
--O DISTINCT SERVE PARA QUE AO INVÉS DE MOSTRAR ESSAS LINHAS REPETIDAS
--MOSTREMOS APENAS UMA VEZ

--NESTE SELECT HAVERÁ REPETIÇÃO
SELECT EMBALAGEM FROM TABELA_DE_PRODUTOS;
--JÁ NESSE NÃO HAVERÁ
SELECT DISTINCT EMBALAGEM FROM TABELA_DE_PRODUTOS;

SELECT EMBALAGEM, SABOR FROM TABELA_DE_PRODUTOS WHERE SABOR = 'Laranja';

SELECT DISTINCT EMBALAGEM, SABOR FROM TABELA_DE_PRODUTOS WHERE SABOR = 'Laranja';

--AGORA VEREMOS COMO LIMITAR SAÍDAS COM O ROWNUM
--ESTE CARA É INTERNO A TABELA E DEFINE O NÚMERO DA LINHA
--OU SEJA COM ELE PODEMOS SELECIONAR OS 5 PRIMEIROS DA TABELA POR EXEMPLO
--CONSULTAS COM ROWNUM SÓ ACEITAM OS OPERADORES CONDICIONAIS < E <=
--CASO EU QUEIRA PEGAR OS ÚLTIMOS EU TERIA QUE UTILIZAR SUBQUERY MAS ISSO 
--AINDA NÃO FOI VISTO ENTÃO FICA MAIS PARA FRENTE

SELECT ROWNUM, CODIGO_DO_PRODUTO, NOME_DO_PRODUTO FROM TABELA_DE_PRODUTOS;

SELECT ROWNUM, CODIGO_DO_PRODUTO, NOME_DO_PRODUTO FROM TABELA_DE_PRODUTOS
WHERE ROWNUM <= 5;

SELECT ROWNUM, CODIGO_DO_PRODUTO, NOME_DO_PRODUTO FROM TABELA_DE_PRODUTOS
WHERE ROWNUM < 10;

--AGORA VEREMOS O ORDER BY - ELE SERVE PARA ORDENAR
--POR PADRAO ELE É ASC (ASCENDENTE - MENOR PARA O MAIOR) MAS PODEMOS FORÇAR ELE
--A SER DESC (DESCENDENTE - MAIOR PARA O MENOR)
--PODEMOS SELECIONAR UM OU MAIS CAMPOS
-- NO CASO DE UM CAMPO

--MENOR PARA O MAIOR
SELECT * FROM TABELA_DE_PRODUTOS ORDER BY PRECO_DE_LISTA;

--MAIOR PARA O MENOR
SELECT * FROM TABELA_DE_PRODUTOS ORDER BY PRECO_DE_LISTA DESC;

--NO CASO DE MAIS DE UM CAMPO:
--HÁ UMA QUEBRA - ELE ORDENA PELO PRIMEIRO CAMPO SELECIONADO E DENTRO DESSE
--CAMPO ELE ORDENA PELO PRÓXIMO CAMPO SELECIONADO E ASSIM POR DIANTE

--NESTE CASO ELE VAI ORDENAR PRIMEIRO POR NOME
--DENDRO DE CADA GRUPO DA ORDEM POR NOME (A FALSA ORDEM ALFABÉTICA)
--ELE VAI ORDENAR PELO PREÇO DO MENOR PARA O MAIOR
SELECT * FROM TABELA_DE_PRODUTOS 
ORDER BY NOME_DO_PRODUTO ASC, PRECO_DE_LISTA ASC;

--AGORA VEREMOS O GROUP BY
--SERVE PARA AGRUPAMENTO, A EXPRESSÃO BÁSICA É
--SELECT COLUNA QUE QUEREMOS AGRUPAR, UMA FUNÇÃO QUE UTILIZAREMOS 
--FROM TABELA GROUP BY COLUNA QUE QUEREMOS AGRUPAR
SELECT ESTADO, SUM(LIMITE_DE_CREDITO) AS TOTAL_CREDITO FROM TABELA_DE_CLIENTES GROUP BY ESTADO;
--ACIMA VEMOS UMA EXPRESSÃO QUE AGRUPA POR ESTADO E PARA CADA ESTADO MOSTRA O 
--LIMITE DE CREDITO TOTAL DO ESTADO

SELECT EMBALAGEM, PRECO_DE_LISTA FROM TABELA_DE_PRODUTOS;

SELECT EMBALAGEM, MAX(PRECO_DE_LISTA) AS MAIOR_PRECO FROM TABELA_DE_PRODUTOS GROUP BY EMBALAGEM;

SELECT EMBALAGEM, COUNT(*) AS NUMERO_PRODUTOS FROM TABELA_DE_PRODUTOS GROUP BY EMBALAGEM;

SELECT BAIRRO, MIN(LIMITE_DE_CREDITO) AS TOTAL_CREDITO FROM TABELA_DE_CLIENTES GROUP BY BAIRRO;

SELECT BAIRRO, AVG(LIMITE_DE_CREDITO) AS TOTAL_CREDITO FROM TABELA_DE_CLIENTES 
WHERE CIDADE = 'Rio de Janeiro' GROUP BY BAIRRO;

SELECT ESTADO, BAIRRO, SUM(LIMITE_DE_CREDITO) AS TOTAL_CREDITO FROM
TABELA_DE_CLIENTES GROUP BY ESTADO, BAIRRO ORDER BY ESTADO, BAIRRO;

--TEMOS AGORA O HAVING QUE É UM FILTRO CONDICIONAL PARA O GROUP BY
SELECT ESTADO, SUM(LIMITE_DE_CREDITO) AS SOMA_LIMITE
FROM TABELA_DE_CLIENTES 
GROUP BY ESTADO
HAVING SUM(LIMITE_DE_CREDITO) >= 900000;
--NO CASO ACIMA FIZEMOS NOSSO GROUP BY E SÓ VAMOS MOSTRAR CASO A SOMA
--DO LIMITE DE CREDITO DO ESTADO SEJA MAIOR QUE 900000

--O FILTRO PARA O HAVING NÃO PRECISA SER OBRIGATÓRIA MENTE  MESMO DO 
--GROUP BY:
SELECT EMBALAGEM, MAX(PRECO_DE_LISTA) AS MAIOR_PRECO,
MIN(PRECO_DE_LISTA) AS MENOR_PRECO FROM TABELA_DE_PRODUTOS
GROUP BY EMBALAGEM
HAVING SUM(PRECO_DE_LISTA) <= 80;

--TEMOS O CASE
SELECT NOME_DO_PRODUTO, PRECO_DE_LISTA, 
(CASE WHEN PRECO_DE_LISTA >= 12 THEN 'PRODUTO CARO'
     WHEN PRECO_DE_lISTA >= 7 AND PRECO_DE_LISTA < 12 THEN 'PRODUTO EM CONTA'
     ELSE 'PRODUTO BARATO'
     END) AS STATUS_PRECO
    FROM TABELA_DE_PRODUTOS
    WHERE SABOR = 'Manga';
--CONFESSO QUE ESSA NÃO PEGUEI TÃO BEM    
    SELECT EMBALAGEM, 
   (CASE WHEN PRECO_DE_LISTA >= 12 THEN 'PRODUTO CARO'
     WHEN PRECO_DE_lISTA >= 7 AND PRECO_DE_LISTA < 12 THEN 'PRODUTO EM CONTA'
     ELSE 'PRODUTO BARATO'
     END) AS STATUS_PRECO,
     AVG(PRECO_DE_LISTA) AS MEDIA_PRECO
    FROM TABELA_DE_PRODUTOS
    GROUP BY EMBALAGEM,
    (CASE WHEN PRECO_DE_LISTA >= 12 THEN 'PRODUTO CARO'
     WHEN PRECO_DE_lISTA >= 7 AND PRECO_DE_LISTA < 12 THEN 'PRODUTO EM CONTA'
     ELSE 'PRODUTO BARATO'
     END)
